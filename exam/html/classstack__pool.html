<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pool of Fast Stack: stack_pool&lt; T, N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Pool of Fast Stack
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstack__pool-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stack_pool&lt; T, N &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Stack_pool concept that can handle multiple stack in the same vector.  
 <a href="classstack__pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stack__pool_8hpp_source.html">stack_pool.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad49fadb28949759e5a717d7c40dd09df"><td class="memItemLeft" align="right" valign="top"><a id="ad49fadb28949759e5a717d7c40dd09df" name="ad49fadb28949759e5a717d7c40dd09df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="class__iterator.html">_iterator</a>&lt; <a class="el" href="classstack__pool.html">stack_pool</a>, T, N &gt;</td></tr>
<tr class="separator:ad49fadb28949759e5a717d7c40dd09df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d0f043dece7d87c346d6d308490881"><td class="memItemLeft" align="right" valign="top"><a id="a88d0f043dece7d87c346d6d308490881" name="a88d0f043dece7d87c346d6d308490881"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="class__iterator.html">_iterator</a>&lt; <a class="el" href="classstack__pool.html">stack_pool</a>, const T, N &gt;</td></tr>
<tr class="separator:a88d0f043dece7d87c346d6d308490881"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1c64b83a921a284670c37451f24d277a"><td class="memItemLeft" align="right" valign="top"><a id="a1c64b83a921a284670c37451f24d277a" name="a1c64b83a921a284670c37451f24d277a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>stack_pool</b> () noexcept</td></tr>
<tr class="memdesc:a1c64b83a921a284670c37451f24d277a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new stack pool object which capacity is 0. <br /></td></tr>
<tr class="separator:a1c64b83a921a284670c37451f24d277a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcc8c129581828781018109e18596c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#a5dcc8c129581828781018109e18596c5">stack_pool</a> (size_type n)</td></tr>
<tr class="memdesc:a5dcc8c129581828781018109e18596c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new stack pool object which capacity is n.  <a href="classstack__pool.html#a5dcc8c129581828781018109e18596c5">More...</a><br /></td></tr>
<tr class="separator:a5dcc8c129581828781018109e18596c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45918a1d3694ad3244163e59a8cb3aae"><td class="memItemLeft" align="right" valign="top"><a id="a45918a1d3694ad3244163e59a8cb3aae" name="a45918a1d3694ad3244163e59a8cb3aae"></a>
<a class="el" href="class__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (stack_type x) noexcept</td></tr>
<tr class="separator:a45918a1d3694ad3244163e59a8cb3aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c017d7def2f88038b7d8b176444586c"><td class="memItemLeft" align="right" valign="top"><a id="a1c017d7def2f88038b7d8b176444586c" name="a1c017d7def2f88038b7d8b176444586c"></a>
<a class="el" href="class__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (stack_type) noexcept</td></tr>
<tr class="separator:a1c017d7def2f88038b7d8b176444586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806cccf13890c9e0d5e7d6163a5fbf8f"><td class="memItemLeft" align="right" valign="top"><a id="a806cccf13890c9e0d5e7d6163a5fbf8f" name="a806cccf13890c9e0d5e7d6163a5fbf8f"></a>
<a class="el" href="class__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (stack_type x) const noexcept</td></tr>
<tr class="separator:a806cccf13890c9e0d5e7d6163a5fbf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd964bd5f2bcbacbd146b579c875e217"><td class="memItemLeft" align="right" valign="top"><a id="abd964bd5f2bcbacbd146b579c875e217" name="abd964bd5f2bcbacbd146b579c875e217"></a>
<a class="el" href="class__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (stack_type) const noexcept</td></tr>
<tr class="separator:abd964bd5f2bcbacbd146b579c875e217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f8ac0d84ec0246a2aaf6f5520d1eb7"><td class="memItemLeft" align="right" valign="top"><a id="aa9f8ac0d84ec0246a2aaf6f5520d1eb7" name="aa9f8ac0d84ec0246a2aaf6f5520d1eb7"></a>
<a class="el" href="class__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> (stack_type x) const noexcept</td></tr>
<tr class="separator:aa9f8ac0d84ec0246a2aaf6f5520d1eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95641ab63a05d33c4d2d233dfab92e15"><td class="memItemLeft" align="right" valign="top"><a id="a95641ab63a05d33c4d2d233dfab92e15" name="a95641ab63a05d33c4d2d233dfab92e15"></a>
<a class="el" href="class__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> (stack_type) const noexcept</td></tr>
<tr class="separator:a95641ab63a05d33c4d2d233dfab92e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36a2988a7d4621e9d5e42d445aea9bb"><td class="memItemLeft" align="right" valign="top">stack_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#ac36a2988a7d4621e9d5e42d445aea9bb">new_stack</a> () const noexcept</td></tr>
<tr class="memdesc:ac36a2988a7d4621e9d5e42d445aea9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new stack in the <a class="el" href="classstack__pool.html" title="Stack_pool concept that can handle multiple stack in the same vector.">stack_pool</a>.  <a href="classstack__pool.html#ac36a2988a7d4621e9d5e42d445aea9bb">More...</a><br /></td></tr>
<tr class="separator:ac36a2988a7d4621e9d5e42d445aea9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc184608b133a7cffbce1825c849bb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#a5fc184608b133a7cffbce1825c849bb5">reserve</a> (size_type n)</td></tr>
<tr class="memdesc:a5fc184608b133a7cffbce1825c849bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity of the vector to a value that's greater or equal to n. If n is greater than the current <a class="el" href="classstack__pool.html#ac2395e6e311e8a82cba86069eacf6c9b" title="Returns the size of the storage space currently allocated for the vector, expressed in terms of eleme...">capacity()</a> new storage is allocated.  <a href="classstack__pool.html#a5fc184608b133a7cffbce1825c849bb5">More...</a><br /></td></tr>
<tr class="separator:a5fc184608b133a7cffbce1825c849bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2395e6e311e8a82cba86069eacf6c9b"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#ac2395e6e311e8a82cba86069eacf6c9b">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:ac2395e6e311e8a82cba86069eacf6c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the storage space currently allocated for the vector, expressed in terms of elements.  <a href="classstack__pool.html#ac2395e6e311e8a82cba86069eacf6c9b">More...</a><br /></td></tr>
<tr class="separator:ac2395e6e311e8a82cba86069eacf6c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaeda1da3346de3b492dbedfee93ca96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#abaeda1da3346de3b492dbedfee93ca96">empty</a> (stack_type x) const noexcept</td></tr>
<tr class="memdesc:abaeda1da3346de3b492dbedfee93ca96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a stack is empty.  <a href="classstack__pool.html#abaeda1da3346de3b492dbedfee93ca96">More...</a><br /></td></tr>
<tr class="separator:abaeda1da3346de3b492dbedfee93ca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1c33461b9bd4aa1866163861ac9c72"><td class="memItemLeft" align="right" valign="top">stack_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#a8d1c33461b9bd4aa1866163861ac9c72">end</a> () const noexcept</td></tr>
<tr class="memdesc:a8d1c33461b9bd4aa1866163861ac9c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the common end of the stacks.  <a href="classstack__pool.html#a8d1c33461b9bd4aa1866163861ac9c72">More...</a><br /></td></tr>
<tr class="separator:a8d1c33461b9bd4aa1866163861ac9c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa249aa79eec3dff1f4bd32673eb12aaa"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#aa249aa79eec3dff1f4bd32673eb12aaa">value</a> (stack_type x)</td></tr>
<tr class="memdesc:aa249aa79eec3dff1f4bd32673eb12aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a node.  <a href="classstack__pool.html#aa249aa79eec3dff1f4bd32673eb12aaa">More...</a><br /></td></tr>
<tr class="separator:aa249aa79eec3dff1f4bd32673eb12aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12ca22655734be12f0ebedceb3cd07f"><td class="memItemLeft" align="right" valign="top"><a id="ae12ca22655734be12f0ebedceb3cd07f" name="ae12ca22655734be12f0ebedceb3cd07f"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (stack_type x) const</td></tr>
<tr class="separator:ae12ca22655734be12f0ebedceb3cd07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39679603450a8cd53bde9b35a05165de"><td class="memItemLeft" align="right" valign="top">stack_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#a39679603450a8cd53bde9b35a05165de">next</a> (stack_type x)</td></tr>
<tr class="memdesc:a39679603450a8cd53bde9b35a05165de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the next node.  <a href="classstack__pool.html#a39679603450a8cd53bde9b35a05165de">More...</a><br /></td></tr>
<tr class="separator:a39679603450a8cd53bde9b35a05165de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88eb6d63010db71e2e09a2619729e821"><td class="memItemLeft" align="right" valign="top"><a id="a88eb6d63010db71e2e09a2619729e821" name="a88eb6d63010db71e2e09a2619729e821"></a>
const stack_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>next</b> (stack_type x) const</td></tr>
<tr class="separator:a88eb6d63010db71e2e09a2619729e821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9be9a76fb78c3668d294630c46ce67"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#adc9be9a76fb78c3668d294630c46ce67">first</a> (stack_type x)</td></tr>
<tr class="memdesc:adc9be9a76fb78c3668d294630c46ce67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the node is the head of the stack.  <a href="classstack__pool.html#adc9be9a76fb78c3668d294630c46ce67">More...</a><br /></td></tr>
<tr class="separator:adc9be9a76fb78c3668d294630c46ce67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caea2478371a54f59f8be6f0db6be23"><td class="memItemLeft" align="right" valign="top"><a id="a1caea2478371a54f59f8be6f0db6be23" name="a1caea2478371a54f59f8be6f0db6be23"></a>
const bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>first</b> (stack_type x) const</td></tr>
<tr class="separator:a1caea2478371a54f59f8be6f0db6be23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07028e5167a9e9f83b49df2bb20cba6"><td class="memItemLeft" align="right" valign="top">stack_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#ab07028e5167a9e9f83b49df2bb20cba6">push</a> (const T &amp;val, stack_type head)</td></tr>
<tr class="memdesc:ab07028e5167a9e9f83b49df2bb20cba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert in a specific stack a new value.  <a href="classstack__pool.html#ab07028e5167a9e9f83b49df2bb20cba6">More...</a><br /></td></tr>
<tr class="separator:ab07028e5167a9e9f83b49df2bb20cba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aeadb825ff55809b1d035af2589502f"><td class="memItemLeft" align="right" valign="top">stack_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#a3aeadb825ff55809b1d035af2589502f">push</a> (T &amp;&amp;val, stack_type head)</td></tr>
<tr class="memdesc:a3aeadb825ff55809b1d035af2589502f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert in a specific stack a new value.  <a href="classstack__pool.html#a3aeadb825ff55809b1d035af2589502f">More...</a><br /></td></tr>
<tr class="separator:a3aeadb825ff55809b1d035af2589502f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662a189732de30747e1a07674536194a"><td class="memItemLeft" align="right" valign="top">stack_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#a662a189732de30747e1a07674536194a">pop</a> (stack_type x)</td></tr>
<tr class="memdesc:a662a189732de30747e1a07674536194a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first element of a given stack.  <a href="classstack__pool.html#a662a189732de30747e1a07674536194a">More...</a><br /></td></tr>
<tr class="separator:a662a189732de30747e1a07674536194a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090ab2cc80e9c1e82c655b64da7d4c79"><td class="memItemLeft" align="right" valign="top">stack_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#a090ab2cc80e9c1e82c655b64da7d4c79">free_stack</a> (stack_type x)</td></tr>
<tr class="memdesc:a090ab2cc80e9c1e82c655b64da7d4c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the elements of a given stack.  <a href="classstack__pool.html#a090ab2cc80e9c1e82c655b64da7d4c79">More...</a><br /></td></tr>
<tr class="separator:a090ab2cc80e9c1e82c655b64da7d4c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4147f3f3591aca9162d4917509cdc2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#add4147f3f3591aca9162d4917509cdc2">length</a> (stack_type x) noexcept</td></tr>
<tr class="memdesc:add4147f3f3591aca9162d4917509cdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the length of a given stack.  <a href="classstack__pool.html#add4147f3f3591aca9162d4917509cdc2">More...</a><br /></td></tr>
<tr class="separator:add4147f3f3591aca9162d4917509cdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66edafb53a086702f14dbadb1118447"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#ac66edafb53a086702f14dbadb1118447">print_stack</a> (stack_type x) noexcept</td></tr>
<tr class="memdesc:ac66edafb53a086702f14dbadb1118447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a stack from the head until the end.  <a href="classstack__pool.html#ac66edafb53a086702f14dbadb1118447">More...</a><br /></td></tr>
<tr class="separator:ac66edafb53a086702f14dbadb1118447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad296535fdb11398528bfdf15270c4252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack__pool.html#ad296535fdb11398528bfdf15270c4252">print_pool</a> () noexcept</td></tr>
<tr class="memdesc:ad296535fdb11398528bfdf15270c4252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the pool.  <a href="classstack__pool.html#ad296535fdb11398528bfdf15270c4252">More...</a><br /></td></tr>
<tr class="separator:ad296535fdb11398528bfdf15270c4252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename N = std::size_t&gt;<br />
class stack_pool&lt; T, N &gt;</div><p >Stack_pool concept that can handle multiple stack in the same vector. </p>
<p >The user who interfaces with the following implementation must correctly manage the push and the stack operations and in particular the return type which corresponds to the head of the stack.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value_type Type of the value. </td></tr>
    <tr><td class="paramname">N</td><td>stack_type Type of the stack head (default std::size_t). </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5dcc8c129581828781018109e18596c5" name="a5dcc8c129581828781018109e18596c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcc8c129581828781018109e18596c5">&#9670;&nbsp;</a></span>stack_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;<a class="el" href="classstack__pool.html">::stack_pool</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new stack pool object which capacity is n. </p>
<p >Exception: (inherited from std::vector::reserve method)</p><ul>
<li>std::length_error if n &gt; max_size().</li>
<li>std::bad_alloc by Allocator::allocate().</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Initial capacity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2395e6e311e8a82cba86069eacf6c9b" name="ac2395e6e311e8a82cba86069eacf6c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2395e6e311e8a82cba86069eacf6c9b">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the storage space currently allocated for the vector, expressed in terms of elements. </p>
<p >This is a read-only function that it does not modify the status of the object.</p>
<p >Exception:</p><ul>
<li>No-throw guarantee: this member functions never throws exceptions.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>size_type Pool capacity. </dd></dl>

</div>
</div>
<a id="abaeda1da3346de3b492dbedfee93ca96" name="abaeda1da3346de3b492dbedfee93ca96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaeda1da3346de3b492dbedfee93ca96">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">stack_type&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a stack is empty. </p>
<p >This is a read-only function that it does not modify the status of the object.</p>
<p >Exception:</p><ul>
<li>No-throw guarantee: this member functions never throws exceptions.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Head of the stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the stack is empty. </dd>
<dd>
false If the stack is not empty. </dd></dl>

</div>
</div>
<a id="a8d1c33461b9bd4aa1866163861ac9c72" name="a8d1c33461b9bd4aa1866163861ac9c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1c33461b9bd4aa1866163861ac9c72">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stack_type <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the common end of the stacks. </p>
<dl class="section return"><dt>Returns</dt><dd>stack_type </dd></dl>

</div>
</div>
<a id="adc9be9a76fb78c3668d294630c46ce67" name="adc9be9a76fb78c3668d294630c46ce67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9be9a76fb78c3668d294630c46ce67">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool &amp; <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::first </td>
          <td>(</td>
          <td class="paramtype">stack_type&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the node is the head of the stack. </p>
<p >Exception: (inherited from node method)</p><ul>
<li><a class="el" href="struct_range_checking_exception.html" title="RangeCheckingException handle the event in which a user tries to access a portion of memory that does...">RangeCheckingException</a> if an index not in range of the pool is is given. This avoid undefined behaviour and segmentation fault.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Index of the node (usually it will the head of the stack). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node is the head. </dd>
<dd>
false if the node is not the head. </dd></dl>

</div>
</div>
<a id="a090ab2cc80e9c1e82c655b64da7d4c79" name="a090ab2cc80e9c1e82c655b64da7d4c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090ab2cc80e9c1e82c655b64da7d4c79">&#9670;&nbsp;</a></span>free_stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stack_type <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::free_stack </td>
          <td>(</td>
          <td class="paramtype">stack_type&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all the elements of a given stack. </p>
<p >Exception: (inherited from pop method)</p><ul>
<li><a class="el" href="struct_not_stack_head_exception.html" title="NotStackHeadException handle the event in which a user tries to pop a stack by passing a no-head elem...">NotStackHeadException</a> if a no-head is passed</li>
<li><a class="el" href="struct_empty_stack_exception.html" title="EmptyStackException handle the event in which a user tries to pop an empty stack.">EmptyStackException</a> if an empty stack is passed</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Head of the stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stack_type New head of the stack which will be equal to end(). </dd></dl>

</div>
</div>
<a id="add4147f3f3591aca9162d4917509cdc2" name="add4147f3f3591aca9162d4917509cdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4147f3f3591aca9162d4917509cdc2">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::length </td>
          <td>(</td>
          <td class="paramtype">stack_type&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the length of a given stack. </p>
<p >Exception:</p><ul>
<li>No-throw guarantee: this member functions never throws exceptions</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Head of the stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto Length of the stack. </dd></dl>

</div>
</div>
<a id="ac36a2988a7d4621e9d5e42d445aea9bb" name="ac36a2988a7d4621e9d5e42d445aea9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36a2988a7d4621e9d5e42d445aea9bb">&#9670;&nbsp;</a></span>new_stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stack_type <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::new_stack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new stack in the <a class="el" href="classstack__pool.html" title="Stack_pool concept that can handle multiple stack in the same vector.">stack_pool</a>. </p>
<p >This is a read-only function that it does not modify the status of the object.</p>
<p >Exception:</p><ul>
<li>No-throw guarantee: this member functions never throws exceptions.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>stack_type Head of the new stack equals to the end. </dd></dl>

</div>
</div>
<a id="a39679603450a8cd53bde9b35a05165de" name="a39679603450a8cd53bde9b35a05165de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39679603450a8cd53bde9b35a05165de">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stack_type &amp; <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::next </td>
          <td>(</td>
          <td class="paramtype">stack_type&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index of the next node. </p>
<p >Exception: (inherited from node method)</p><ul>
<li><a class="el" href="struct_range_checking_exception.html" title="RangeCheckingException handle the event in which a user tries to access a portion of memory that does...">RangeCheckingException</a> if an index not in range of the pool is is given. This avoid undefined behaviour and segmentation fault.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Index of the node (usually it will the head of the stack). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; Value of the node. </dd></dl>

</div>
</div>
<a id="a662a189732de30747e1a07674536194a" name="a662a189732de30747e1a07674536194a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662a189732de30747e1a07674536194a">&#9670;&nbsp;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stack_type <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">stack_type&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the first element of a given stack. </p>
<p >Exception:</p><ul>
<li><a class="el" href="struct_not_stack_head_exception.html" title="NotStackHeadException handle the event in which a user tries to pop a stack by passing a no-head elem...">NotStackHeadException</a> if a no-head is passed.</li>
<li><a class="el" href="struct_empty_stack_exception.html" title="EmptyStackException handle the event in which a user tries to pop an empty stack.">EmptyStackException</a> if an empty stack is passed.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Head of the stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stack_type New head of the stack which will be equal to end(). </dd></dl>

</div>
</div>
<a id="ad296535fdb11398528bfdf15270c4252" name="ad296535fdb11398528bfdf15270c4252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad296535fdb11398528bfdf15270c4252">&#9670;&nbsp;</a></span>print_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::print_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the pool. </p>
<p >Useful for debug info</p>
<p >Exception:</p><ul>
<li>No-throw guarantee: this member functions never throws exceptions Const </li>
</ul>

</div>
</div>
<a id="ac66edafb53a086702f14dbadb1118447" name="ac66edafb53a086702f14dbadb1118447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66edafb53a086702f14dbadb1118447">&#9670;&nbsp;</a></span>print_stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::print_stack </td>
          <td>(</td>
          <td class="paramtype">stack_type&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a stack from the head until the end. </p>
<p >Exception:</p><ul>
<li>No-throw guarantee: this member functions never throws exceptions</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Head of the stack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab07028e5167a9e9f83b49df2bb20cba6" name="ab07028e5167a9e9f83b49df2bb20cba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07028e5167a9e9f83b49df2bb20cba6">&#9670;&nbsp;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stack_type <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stack_type&#160;</td>
          <td class="paramname"><em>head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert in a specific stack a new value. </p>
<p >Exception: (inherited from _push method)</p><ul>
<li><a class="el" href="struct_not_equal_type_exception.html" title="NotEqualTypeException handle the event in which a user tries to insert a different type value in a st...">NotEqualTypeException</a> if a different type from the type_value is passed.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to insert in the stack. (L-value reference). </td></tr>
    <tr><td class="paramname">head</td><td>Head of the stack in which the value must be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stack_type New head of the stack. </dd></dl>

</div>
</div>
<a id="a3aeadb825ff55809b1d035af2589502f" name="a3aeadb825ff55809b1d035af2589502f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aeadb825ff55809b1d035af2589502f">&#9670;&nbsp;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stack_type <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::push </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stack_type&#160;</td>
          <td class="paramname"><em>head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert in a specific stack a new value. </p>
<p >Exception:</p><ul>
<li><a class="el" href="struct_not_equal_type_exception.html" title="NotEqualTypeException handle the event in which a user tries to insert a different type value in a st...">NotEqualTypeException</a> if a different type from the type_value is passed.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to insert in the stack. (R-value reference). </td></tr>
    <tr><td class="paramname">head</td><td>Head of the stack in which the value must be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stack_type New head of the stack. </dd></dl>

</div>
</div>
<a id="a5fc184608b133a7cffbce1825c849bb5" name="a5fc184608b133a7cffbce1825c849bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc184608b133a7cffbce1825c849bb5">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the capacity of the vector to a value that's greater or equal to n. If n is greater than the current <a class="el" href="classstack__pool.html#ac2395e6e311e8a82cba86069eacf6c9b" title="Returns the size of the storage space currently allocated for the vector, expressed in terms of eleme...">capacity()</a> new storage is allocated. </p>
<p >Exception:</p><ul>
<li>std::length_error if n &gt; max_size()</li>
<li>std::bad_alloc by Allocator::allocate()</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Capacity that the user want to allocate initially . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa249aa79eec3dff1f4bd32673eb12aaa" name="aa249aa79eec3dff1f4bd32673eb12aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa249aa79eec3dff1f4bd32673eb12aaa">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classstack__pool.html">stack_pool</a>&lt; T, N &gt;::value </td>
          <td>(</td>
          <td class="paramtype">stack_type&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of a node. </p>
<p >Exception: (inherited from node method)</p><ul>
<li><a class="el" href="struct_range_checking_exception.html" title="RangeCheckingException handle the event in which a user tries to access a portion of memory that does...">RangeCheckingException</a> if an index not in range of the pool is is given. This avoid undefined behaviour and segmentation fault.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Index of the node (usually it will the head of the stack). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; Value of the node. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="stack__pool_8hpp_source.html">stack_pool.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
